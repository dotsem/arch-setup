#!/usr/bin/env bash
# System Unit Test - Validate system configuration and functionality

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Test results
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_WARNED=0
FAILED_TESTS=()
WARNING_TESTS=()
TEST_RESULTS=()

# JSON output
JSON_OUTPUT=""
JSON_FILE=""

# Parse arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -j|--json)
                JSON_FILE="$2"
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

show_help() {
    cat << EOF
Usage: sysunit [OPTIONS]

System Unit Test - Validates system configuration and functionality

OPTIONS:
    -j, --json <file>    Save results to JSON file
    -h, --help          Show this help message

EXAMPLES:
    sysunit                           # Run tests (normal output)
    sysunit -j results.json          # Run tests and save JSON
    sysunit --json ~/test-results.json

EOF
}

# Setup sudo access
setup_sudo() {
    # Check if we need sudo for any tests
    if ! sudo -n true 2>/dev/null; then
        echo -e "${YELLOW}Some tests require sudo access.${NC}"
        echo -e "${YELLOW}Please enter your password:${NC}"
        if ! sudo -v; then
            echo -e "${RED}Failed to get sudo access. Some tests will be skipped.${NC}"
            return 1
        fi
    fi
    
    # Keep sudo alive in background
    (
        while true; do
            sudo -n true
            sleep 60
            kill -0 "$$" 2>/dev/null || exit
        done
    ) 2>/dev/null &
    SUDO_KEEPALIVE_PID=$!
    
    # Cleanup on exit
    trap "sudo -K; kill $SUDO_KEEPALIVE_PID 2>/dev/null" EXIT INT TERM
    
    return 0
}

print_header() {
    echo -e "\n${BLUE}=====================================${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}=====================================${NC}"
}

test_result() {
    local test_name="$1"
    local result="$2"
    local details="${3:-}"
    local category="${4:-general}"
    
    # Store result for JSON output
    TEST_RESULTS+=("{\"name\":\"$test_name\",\"status\":\"$result\",\"category\":\"$category\",\"details\":\"$details\"}")
    
    case "$result" in
        pass)
            echo -e "${GREEN}✓${NC} $test_name"
            ((TESTS_PASSED++))
            ;;
        fail)
            echo -e "${RED}✗${NC} $test_name${details:+ - $details}"
            ((TESTS_FAILED++))
            FAILED_TESTS+=("$test_name")
            ;;
        warn)
            echo -e "${YELLOW}⚠${NC} $test_name${details:+ - $details}"
            ((TESTS_WARNED++))
            WARNING_TESTS+=("$test_name")
            ;;
        skip)
            echo -e "${CYAN}○${NC} $test_name (skipped)"
            ;;
    esac
}

# Helper function to convert exit code to result
exit_to_result() {
    if [ "$1" -eq 0 ]; then
        echo "pass"
    else
        echo "fail"
    fi
}

# ===== SYSTEM TESTS =====

test_kernel() {
    print_header "Kernel Tests"
    
    # Test: Kernel is running
    local kernel_version=$(uname -r 2>/dev/null)
    if [ -n "$kernel_version" ]; then
        test_result "Kernel is running" "pass" "$kernel_version" "kernel"
    else
        test_result "Kernel is running" "fail" "" "kernel"
    fi
    
    # Test: Kernel modules are loaded
    local module_count=$(lsmod 2>/dev/null | tail -n +2 | wc -l)
    if [ "$module_count" -gt 0 ]; then
        test_result "Kernel modules loaded" "pass" "$module_count modules" "kernel"
    else
        test_result "Kernel modules loaded" "fail" "" "kernel"
    fi
    
    # Test: Kernel parameters accessible
    if [ -r /proc/cmdline ]; then
        test_result "Kernel parameters accessible" "pass" "" "kernel"
    else
        test_result "Kernel parameters accessible" "fail" "" "kernel"
    fi
    
    # Test: System uptime
    local uptime=$(uptime -p 2>/dev/null || echo "unknown")
    test_result "System uptime" "pass" "$uptime" "kernel"
}

test_network() {
    print_header "Network Tests"
    
    # Test: NetworkManager is running
    if systemctl is-active NetworkManager > /dev/null 2>&1; then
        test_result "NetworkManager is active" "pass" "" "network"
    else
        test_result "NetworkManager is active" "fail" "Service not running" "network"
    fi
    
    # Test: NetworkManager is enabled
    if systemctl is-enabled NetworkManager > /dev/null 2>&1; then
        test_result "NetworkManager is enabled" "pass" "" "network"
    else
        test_result "NetworkManager is enabled" "warn" "Not enabled at boot" "network"
    fi
    
    # Test: Network interfaces
    local interface_count=$(ip link show | grep -c "^[0-9]")
    if [ "$interface_count" -gt 0 ]; then
        test_result "Network interfaces present" "pass" "$interface_count interfaces" "network"
    else
        test_result "Network interfaces present" "fail" "" "network"
    fi
    
    # Test: Internet connectivity
    if ping -c 1 -W 2 archlinux.org > /dev/null 2>&1; then
        test_result "Internet connectivity" "pass" "" "network"
    else
        test_result "Internet connectivity" "fail" "Cannot reach archlinux.org" "network"
    fi
    
    # Test: DNS resolution
    if nslookup archlinux.org > /dev/null 2>&1; then
        test_result "DNS resolution" "pass" "" "network"
    else
        test_result "DNS resolution" "fail" "DNS lookup failed" "network"
    fi
    
    # Test: Default gateway
    if ip route | grep -q "^default"; then
        local gateway=$(ip route | grep "^default" | awk '{print $3}' | head -1)
        test_result "Default gateway configured" "pass" "$gateway" "network"
    else
        test_result "Default gateway configured" "fail" "" "network"
    fi
}

test_audio() {
    print_header "Audio Tests"
    
    # Test: PipeWire is running
    pgrep -x pipewire > /dev/null 2>&1
    test_result "PipeWire is running" $?
    
    # Test: WirePlumber is running
    pgrep -x wireplumber > /dev/null 2>&1
    test_result "WirePlumber is running" $?
    
    # Test: PipeWire-pulse is running
    pgrep -x pipewire-pulse > /dev/null 2>&1
    test_result "PipeWire-pulse is running" $?
    
    # Test: Audio devices detected
    pactl list sinks short | grep -q .
    test_result "Audio devices detected" $?
}

test_display() {
    print_header "Display Tests"
    
    # Test: Wayland display variable
    [ -n "$WAYLAND_DISPLAY" ] || [ -n "$DISPLAY" ]
    test_result "Display variable set" $?
    
    # Test: Hyprland config exists
    [ -f "$HOME/.config/hypr/hyprland.conf" ]
    test_result "Hyprland config exists" $?
}

test_shell() {
    print_header "Shell Tests"
    
    # Test: Zsh is installed
    if command -v zsh > /dev/null 2>&1; then
        local zsh_version=$(zsh --version 2>/dev/null | awk '{print $2}')
        test_result "Zsh is installed" "pass" "$zsh_version" "shell"
    else
        test_result "Zsh is installed" "fail" "" "shell"
    fi
    
    # Test: Zsh is default shell (fixed to work properly)
    local current_shell=$(getent passwd "$USER" | cut -d: -f7)
    local zsh_path=$(command -v zsh 2>/dev/null)
    if [ "$current_shell" = "$zsh_path" ]; then
        test_result "Zsh is default shell" "pass" "" "shell"
    else
        test_result "Zsh is default shell" "fail" "Current: $current_shell" "shell"
    fi
    
    # Test: Oh My Zsh is installed
    if [ -d "$HOME/.oh-my-zsh" ]; then
        test_result "Oh My Zsh is installed" "pass" "" "shell"
    else
        test_result "Oh My Zsh is installed" "warn" "Not installed" "shell"
    fi
    
    # Test: Zsh plugins
    if [ -f "$HOME/.zshrc" ]; then
        test_result "Zsh configuration exists" "pass" "" "shell"
        
        # Check for common plugins
        if grep -q "plugins=" "$HOME/.zshrc"; then
            local plugins=$(grep "plugins=" "$HOME/.zshrc" | head -1)
            test_result "Zsh plugins configured" "pass" "" "shell"
        fi
    else
        test_result "Zsh configuration exists" "warn" "No .zshrc found" "shell"
    fi
}

test_git() {
    print_header "Git Tests"
    
    # Test: Git is installed
    command -v git > /dev/null 2>&1
    test_result "Git is installed" $?
    
    # Test: Git user name configured
    git config --global user.name > /dev/null 2>&1
    test_result "Git user.name configured" $?
    
    # Test: Git user email configured
    git config --global user.email > /dev/null 2>&1
    test_result "Git user.email configured" $?
}

test_package_managers() {
    print_header "Package Manager Tests"
    
    # Test: Pacman is working
    pacman --version > /dev/null 2>&1
    test_result "Pacman is working" $?
    
    # Test: Yay is installed
    command -v yay > /dev/null 2>&1
    test_result "Yay is installed" $?
    
    # Test: Flatpak is installed
    command -v flatpak > /dev/null 2>&1
    test_result "Flatpak is installed" $?
    
    # Test: Flathub remote configured
    flatpak remotes | grep -q flathub
    test_result "Flathub remote configured" $?
}

test_python() {
    print_header "Python Tests"
    
    # Test: Python is installed
    if command -v python3 > /dev/null 2>&1; then
        local python_version=$(python3 --version 2>&1 | awk '{print $2}')
        test_result "Python3 is installed" "pass" "$python_version" "python"
    else
        test_result "Python3 is installed" "fail" "" "python"
        return
    fi
    
    # Test: Pip is installed (fixed - try multiple methods)
    if python3 -m pip --version > /dev/null 2>&1; then
        local pip_version=$(python3 -m pip --version 2>&1 | awk '{print $2}')
        test_result "Pip is installed" "pass" "$pip_version" "python"
    elif command -v pip3 > /dev/null 2>&1; then
        local pip_version=$(pip3 --version 2>&1 | awk '{print $2}')
        test_result "Pip is installed" "pass" "$pip_version" "python"
    elif command -v pip > /dev/null 2>&1; then
        local pip_version=$(pip --version 2>&1 | awk '{print $2}')
        test_result "Pip is installed" "pass" "$pip_version" "python"
    else
        test_result "Pip is installed" "fail" "Not found" "python"
    fi
    
    # Test: Python can import basic modules
    if python3 -c "import sys, os" 2> /dev/null; then
        test_result "Python basic imports work" "pass" "" "python"
    else
        test_result "Python basic imports work" "fail" "" "python"
    fi
    
    # Test: Python venv module
    if python3 -c "import venv" 2> /dev/null; then
        test_result "Python venv module available" "pass" "" "python"
    else
        test_result "Python venv module available" "warn" "venv not available" "python"
    fi
}

test_directories() {
    print_header "Directory Structure Tests"
    
    local dirs=(
        "$HOME/.config"
        "$HOME/Documents"
        "$HOME/Downloads"
        "$HOME/Pictures"
        "$HOME/Videos"
        "$HOME/.local/bin"
    )
    
    for dir in "${dirs[@]}"; do
        [ -d "$dir" ]
        test_result "Directory exists: $dir" $?
    done
}

test_boot() {
    print_header "Boot Tests"
    
    # Test: Display manager is enabled
    systemctl is-enabled ly > /dev/null 2>&1
    test_result "Display manager (ly) is enabled" $?
    
    # Test: GRUB is configured
    [ -f /boot/grub/grub.cfg ]
    test_result "GRUB configuration exists" $?
}

test_security() {
    print_header "Security Tests"
    
    # Check if UFW is installed first
    if ! command -v ufw > /dev/null 2>&1; then
        test_result "Firewall (UFW) is installed" "warn" "UFW not installed" "security"
        test_result "Firewall (UFW) is enabled" "skip" "" "security"
        test_result "Firewall (UFW) is active" "skip" "" "security"
    else
        test_result "Firewall (UFW) is installed" "pass" "" "security"
        
        # Test: Firewall is enabled
        if sudo systemctl is-enabled ufw > /dev/null 2>&1; then
            test_result "Firewall (UFW) is enabled" "pass" "" "security"
        else
            test_result "Firewall (UFW) is enabled" "fail" "Not enabled at boot" "security"
        fi
        
        # Test: Firewall is active
        if sudo systemctl is-active ufw > /dev/null 2>&1; then
            test_result "Firewall (UFW) is active" "pass" "" "security"
            
            # Test: UFW status
            local ufw_status=$(sudo ufw status 2>/dev/null | head -1)
            test_result "Firewall status check" "pass" "$ufw_status" "security"
        else
            test_result "Firewall (UFW) is active" "fail" "Service not running" "security"
        fi
    fi
    
    # Test: SSH configuration
    if [ -f /etc/ssh/sshd_config ]; then
        test_result "SSH configuration exists" "pass" "" "security"
        
        # Check if root login is disabled
        if grep -q "^PermitRootLogin no" /etc/ssh/sshd_config 2>/dev/null; then
            test_result "SSH root login disabled" "pass" "" "security"
        else
            test_result "SSH root login disabled" "warn" "Root login may be enabled" "security"
        fi
    fi
    
    # Test: Sudo configuration
    if sudo -l > /dev/null 2>&1; then
        test_result "Sudo access configured" "pass" "" "security"
    else
        test_result "Sudo access configured" "fail" "" "security"
    fi
}

test_flutter() {
    print_header "Flutter Tests (Optional)"
    
    # Test: Flutter is installed
    if command -v flutter > /dev/null 2>&1; then
        test_result "Flutter is installed" 0
        
        # Test: Flutter doctor runs
        flutter doctor > /dev/null 2>&1
        test_result "Flutter doctor runs" $?
    else
        echo -e "${YELLOW}ℹ${NC} Flutter not installed (optional)"
    fi
}

test_hardware() {
    print_header "Hardware Tests"
    
    # Test: CPU information
    if [ -f /proc/cpuinfo ]; then
        local cpu_model=$(grep "model name" /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)
        local cpu_cores=$(nproc)
        test_result "CPU information available" "pass" "$cpu_cores cores" "hardware"
    else
        test_result "CPU information available" "fail" "" "hardware"
    fi
    
    # Test: Memory
    local mem_total=$(free -h | awk '/^Mem:/ {print $2}')
    local mem_used=$(free -h | awk '/^Mem:/ {print $3}')
    test_result "Memory information" "pass" "$mem_used / $mem_total used" "hardware"
    
    # Test: Disk space
    local disk_usage=$(df -h / | awk 'NR==2 {print $5}' | tr -d '%')
    if [ "$disk_usage" -lt 90 ]; then
        test_result "Root filesystem usage" "pass" "${disk_usage}% used" "hardware"
    else
        test_result "Root filesystem usage" "warn" "${disk_usage}% used (high)" "hardware"
    fi
    
    # Test: GPU detection
    if lspci | grep -qi "vga\|3d\|display"; then
        local gpu=$(lspci | grep -i "vga\|3d\|display" | head -1 | cut -d: -f3 | xargs)
        test_result "GPU detected" "pass" "$gpu" "hardware"
    else
        test_result "GPU detected" "warn" "No GPU found" "hardware"
    fi
}

test_services() {
    print_header "System Services Tests"
    
    # Test: Systemd is running
    if systemctl --version > /dev/null 2>&1; then
        test_result "Systemd is running" "pass" "" "services"
    else
        test_result "Systemd is running" "fail" "" "services"
    fi
    
    # Test: Failed services
    local failed_count=$(systemctl --failed --no-pager --no-legend | wc -l)
    if [ "$failed_count" -eq 0 ]; then
        test_result "No failed services" "pass" "" "services"
    else
        test_result "No failed services" "warn" "$failed_count services failed" "services"
    fi
    
    # Test: D-Bus
    if pgrep -x dbus-daemon > /dev/null 2>&1; then
        test_result "D-Bus is running" "pass" "" "services"
    else
        test_result "D-Bus is running" "fail" "" "services"
    fi
}

test_storage() {
    print_header "Storage Tests"
    
    # Test: Filesystem mounts
    local mount_count=$(mount | wc -l)
    test_result "Filesystems mounted" "pass" "$mount_count mounts" "storage"
    
    # Test: Root filesystem
    if mount | grep -q "on / "; then
        local root_fs=$(mount | grep "on / " | awk '{print $5}')
        test_result "Root filesystem mounted" "pass" "$root_fs" "storage"
    else
        test_result "Root filesystem mounted" "fail" "" "storage"
    fi
    
    # Test: TRIM support (for SSDs)
    if command -v fstrim > /dev/null 2>&1; then
        test_result "TRIM utility available" "pass" "" "storage"
        
        # Check if fstrim timer is enabled
        if systemctl is-enabled fstrim.timer > /dev/null 2>&1; then
            test_result "Automatic TRIM enabled" "pass" "" "storage"
        else
            test_result "Automatic TRIM enabled" "warn" "fstrim.timer not enabled" "storage"
        fi
    else
        test_result "TRIM utility available" "skip" "" "storage"
    fi
}

test_users() {
    print_header "User & Permissions Tests"
    
    # Test: Current user
    local current_user=$(whoami)
    test_result "Current user identified" "pass" "$current_user" "users"
    
    # Test: User groups
    local group_count=$(groups | wc -w)
    test_result "User group membership" "pass" "$group_count groups" "users"
    
    # Test: Home directory
    if [ -d "$HOME" ] && [ -w "$HOME" ]; then
        test_result "Home directory accessible" "pass" "$HOME" "users"
    else
        test_result "Home directory accessible" "fail" "" "users"
    fi
    
    # Test: Sudo access (already tested in setup, but verify)
    if sudo -n true 2>/dev/null || sudo -v 2>/dev/null; then
        test_result "Sudo access available" "pass" "" "users"
    else
        test_result "Sudo access available" "fail" "" "users"
    fi
}

test_time() {
    print_header "Time & Locale Tests"
    
    # Test: System time
    local current_time=$(date '+%Y-%m-%d %H:%M:%S')
    test_result "System time" "pass" "$current_time" "time"
    
    # Test: Timezone
    local timezone=$(timedatectl show --property=Timezone --value 2>/dev/null || echo "unknown")
    test_result "Timezone configured" "pass" "$timezone" "time"
    
    # Test: NTP synchronization
    if timedatectl show --property=NTPSynchronized --value 2>/dev/null | grep -q "yes"; then
        test_result "NTP time sync enabled" "pass" "" "time"
    else
        test_result "NTP time sync enabled" "warn" "Time may drift" "time"
    fi
    
    # Test: Locale
    if locale > /dev/null 2>&1; then
        local lang=$(locale | grep "^LANG=" | cut -d= -f2)
        test_result "Locale configured" "pass" "$lang" "time"
    else
        test_result "Locale configured" "warn" "" "time"
    fi
}

# Generate JSON output
generate_json() {
    local timestamp=$(date -Iseconds)
    local hostname=$(hostname)
    local username=$(whoami)
    local total_tests=$((TESTS_PASSED + TESTS_FAILED + TESTS_WARNED))
    
    cat > "$JSON_FILE" << EOF
{
  "metadata": {
    "timestamp": "$timestamp",
    "hostname": "$hostname",
    "username": "$username",
    "sysunit_version": "2.0"
  },
  "summary": {
    "total": $total_tests,
    "passed": $TESTS_PASSED,
    "failed": $TESTS_FAILED,
    "warned": $TESTS_WARNED,
    "success_rate": $(awk "BEGIN {printf \"%.2f\", ($TESTS_PASSED/$total_tests)*100}")
  },
  "results": [
    $(IFS=,; echo "${TEST_RESULTS[*]}")
  ]
}
EOF
}

# ===== MAIN =====

main() {
    parse_args "$@"
    
    echo -e "${BLUE}╔═══════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║                                       ║${NC}"
    echo -e "${BLUE}║        SYSTEM UNIT TESTS (sysunit)    ║${NC}"
    echo -e "${BLUE}║                                       ║${NC}"
    echo -e "${BLUE}╚═══════════════════════════════════════╝${NC}"
    
    # Setup sudo access
    setup_sudo
    
    # Run all test suites
    test_kernel
    test_hardware
    test_network
    test_audio
    test_display
    test_shell
    test_git
    test_package_managers
    test_python
    test_directories
    test_boot
    test_security
    test_storage
    test_services
    test_users
    test_time
    test_flutter
    
    # Summary
    echo -e "\n${BLUE}=====================================${NC}"
    echo -e "${BLUE}  TEST SUMMARY${NC}"
    echo -e "${BLUE}=====================================${NC}"
    echo -e "${GREEN}Passed:${NC}  $TESTS_PASSED"
    echo -e "${RED}Failed:${NC}  $TESTS_FAILED"
    echo -e "${YELLOW}Warnings:${NC} $TESTS_WARNED"
    
    local total=$((TESTS_PASSED + TESTS_FAILED + TESTS_WARNED))
    local success_rate=$(awk "BEGIN {printf \"%.1f\", ($TESTS_PASSED/$total)*100}")
    echo -e "${CYAN}Success Rate:${NC} $success_rate%"
    
    if [ $TESTS_FAILED -gt 0 ]; then
        echo -e "\n${RED}Failed tests:${NC}"
        for test in "${FAILED_TESTS[@]}"; do
            echo -e "  ${RED}✗${NC} $test"
        done
    fi
    
    if [ $TESTS_WARNED -gt 0 ]; then
        echo -e "\n${YELLOW}Warnings:${NC}"
        for test in "${WARNING_TESTS[@]}"; do
            echo -e "  ${YELLOW}⚠${NC} $test"
        done
    fi
    
    # Generate JSON if requested
    if [ -n "$JSON_FILE" ]; then
        generate_json
        echo -e "\n${GREEN}Results saved to:${NC} $JSON_FILE"
    fi
    
    if [ $TESTS_FAILED -gt 0 ]; then
        echo -e "\n${YELLOW}Some tests failed. Review the output above for details.${NC}"
        return 1
    elif [ $TESTS_WARNED -gt 0 ]; then
        echo -e "\n${YELLOW}All critical tests passed, but some warnings were raised.${NC}"
        return 0
    else
        echo -e "\n${GREEN}All tests passed! System is configured correctly.${NC}"
        return 0
    fi
}

# Run if executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
